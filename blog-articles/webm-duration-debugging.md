# The Mysterious Case of audio.duration = Infinity: Debugging WebM Audio in React

## The Problem

Our React AudioPlayer component was completely broken - showing "0:00 / 0:00" with disabled controls, despite having perfectly accessible audio files:

```tsx
// What users saw: Broken player with no duration
<AudioPlayer src={signedUrl} title="My Recording" />
// Result: 0:00 / 0:00, disabled play button
```

## Initial Investigation

The debugging process revealed a surprising issue:

```javascript
// Console output during debugging
console.log("Audio can play - duration:", audio.duration, "readyState:", 3);
// Output: Audio can play - duration: Infinity readyState: 3

// URL was perfect - this worked in browser:
// https://bucket.supabase.co/signed-url-here
// Status: 200, Content-Type: audio/webm, Content-Length: 46529
```

**The mystery**: Signed URL worked perfectly, audio was accessible, but `audio.duration = Infinity`.

## Root Cause Discovery

WebM files generated by browser `MediaRecorder` API don't include reliable duration metadata:

> **Deep Dive**: For a comprehensive technical analysis of why this happens, see [WebM Format Analysis](deep-dives/webm-format-analysis.md).

```javascript
// The problematic audio metadata
const audio = new Audio(webmUrl);
audio.addEventListener("loadedmetadata", () => {
  console.log(audio.duration); // Infinity ❌
  console.log(audio.readyState); // 3 (can play)
});
```

This is a **common browser limitation** - not a bug in our code.

> **Related**: Understanding [HTML5 Audio Events](deep-dives/html5-audio-events.md) helps explain why `loadedmetadata` doesn't guarantee reliable duration information.

## The Solution: Fallback Duration Strategy

Instead of relying on unreliable audio metadata, use the duration calculated during recording:

> **Architecture**: This fallback pattern is part of broader [React Audio Architecture](deep-dives/react-audio-architecture.md) best practices.

```tsx
// Enhanced AudioPlayer with fallback duration
interface AudioPlayerProps {
  src: string;
  title: string;
  duration?: number; // 👈 Fallback from database
}

// In the component:
useEffect(() => {
  const checkDurationFallback = () => {
    if (duration === 0 && propDuration && propDuration > 0) {
      console.log("Using fallback duration:", propDuration);
      setDuration(propDuration);
    }
  };

  const timer = setTimeout(checkDurationFallback, 1000);
  return () => clearTimeout(timer);
}, [duration, propDuration]);
```

## Implementation in HistoryList

```tsx
// Pass database duration to AudioPlayer
<AudioPlayer
  src={playingEntryUrl}
  title={entry.title}
  duration={entry.duration} // 👈 From database, calculated during recording
  onEnded={pauseAudio}
/>
```

## Key Takeaways

1. **WebM + MediaRecorder = No Duration**: Browser-generated WebM files often lack duration metadata
2. **Always Have Fallbacks**: Don't rely solely on browser APIs for critical functionality
3. **Separate Concerns**: Recording calculates → Database stores → Player uses
4. **Debug Systematically**: Console logging revealed the real issue quickly

> **UX Follow-up**: After fixing this technical issue, we discovered UX problems with dual play buttons. See [React Component UX Anti-patterns](react-component-ux-patterns.md) for the solution.

## Before vs After

```javascript
// Before: Broken
audio.duration; // Infinity
playButton.disabled; // true
timeDisplay; // "0:00 / 0:00"

// After: Working
propDuration; // 23.4 (from database)
playButton.disabled; // false
timeDisplay; // "0:00 / 0:23"
```

The solution was simple once we understood the root cause: trust the duration we calculated during recording, not the unreliable WebM metadata.
